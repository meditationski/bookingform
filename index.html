const { Telegraf, Markup } = require('telegraf');
const mysql = require('mysql2/promise');
const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è MySQL –¥–ª—è Railway
let pool;
let isDatabaseInitialized = false;

async function initializeDatabase() {
  try {
    console.log('üîÑ Initializing MySQL connection...');
    
    const dbConfig = {
      host: process.env.MYSQLHOST || 'localhost',
      port: process.env.MYSQLPORT || 3306,
      user: process.env.MYSQLUSER || 'root',
      password: process.env.MYSQLPASSWORD || '',
      database: process.env.MYSQLDATABASE || 'railway',
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0,
      ...(process.env.NODE_ENV === 'production' && {
        ssl: { rejectUnauthorized: false }
      })
    };

    console.log('üìä MySQL Config:', {
      host: dbConfig.host,
      port: dbConfig.port,
      user: dbConfig.user,
      database: dbConfig.database
    });

    pool = mysql.createPool(dbConfig);

    const connection = await pool.getConnection();
    console.log('‚úÖ Connected to MySQL database');
    connection.release();

    await createTables();
    isDatabaseInitialized = true;
    console.log('üéâ Database initialization completed successfully!');
    
  } catch (error) {
    console.error('‚ùå Database initialization error:', error);
    console.log('üîÑ Retrying in 10 seconds...');
    setTimeout(initializeDatabase, 10000);
  }
}

async function createTables() {
  try {
    console.log('üîÑ Creating tables...');
    
    await pool.execute(`
      CREATE TABLE IF NOT EXISTS instructors (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255),
        telegram_username VARCHAR(255) UNIQUE NOT NULL,
        language VARCHAR(50) DEFAULT 'russian',
        is_active BOOLEAN DEFAULT true,
        is_admin BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      ) ENGINE=InnoDB CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci
    `);
    console.log('‚úÖ instructors table ready');

    await pool.execute(`
      CREATE TABLE IF NOT EXISTS orders (
        id INT AUTO_INCREMENT PRIMARY KEY,
        client_name VARCHAR(255) NOT NULL,
        phone VARCHAR(100) NOT NULL,
        email VARCHAR(255) NOT NULL,
        age INT NOT NULL,
        skill_level VARCHAR(100),
        additional_info TEXT,
        sport_type VARCHAR(100) NOT NULL,
        duration VARCHAR(50) NOT NULL,
        participants INT NOT NULL,
        days INT NOT NULL,
        date DATE NOT NULL,
        time TIME NOT NULL,
        total_price INT NOT NULL,
        deposit_price INT NOT NULL,
        remaining_price INT NOT NULL,
        status VARCHAR(50) DEFAULT 'pending',
        instructor_username VARCHAR(255),
        instructor_name VARCHAR(255),
        payment_status VARCHAR(50) DEFAULT 'completed',
        booking_id VARCHAR(100) UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      ) ENGINE=InnoDB CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci
    `);
    console.log('‚úÖ orders table ready');

    await initializeAdminUser();
    
  } catch (error) {
    console.error('‚ùå Table creation error:', error);
    throw error;
  }
}

async function initializeAdminUser() {
  try {
    const ADMIN_USERNAME = process.env.ADMIN_USERNAME ? 
      (process.env.ADMIN_USERNAME.startsWith('@') ? process.env.ADMIN_USERNAME : `@${process.env.ADMIN_USERNAME}`) : 
      '@ski_meditation';

    console.log('üîÑ Checking admin user:', ADMIN_USERNAME);

    const [adminRows] = await pool.execute(
      'SELECT COUNT(*) as count FROM instructors WHERE telegram_username = ?',
      [ADMIN_USERNAME]
    );

    if (adminRows[0].count === 0) {
      await pool.execute(
        `INSERT INTO instructors (name, telegram_username, language, is_admin) 
         VALUES (?, ?, ?, ?)`,
        ['Admin', ADMIN_USERNAME, 'russian', true]
      );
      console.log('‚úÖ Admin user created:', ADMIN_USERNAME);
    } else {
      await pool.execute(
        `UPDATE instructors SET is_admin = true, is_active = true WHERE telegram_username = ?`,
        [ADMIN_USERNAME]
      );
      console.log('‚úÖ Admin user updated:', ADMIN_USERNAME);
    }
  } catch (error) {
    console.error('‚ùå Admin user initialization error:', error);
  }
}

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const BOT_TOKEN = process.env.BOT_TOKEN || '8201481946:AAGpCm40p0ihCFccA-fAuFHFqMoseMb6OLc';
const ADMIN_USERNAME = process.env.ADMIN_USERNAME ? 
    (process.env.ADMIN_USERNAME.startsWith('@') ? process.env.ADMIN_USERNAME : `@${process.env.ADMIN_USERNAME}`) : 
    '@ski_meditation';

console.log('ü§ñ Starting SkiSchool.ge Bot...');
console.log('üëë Admin username:', ADMIN_USERNAME);

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
initializeDatabase();

const bot = new Telegraf(BOT_TOKEN);

// –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–ª—è —Å–æ—Å—Ç–æ—è–Ω–∏–π
const userStates = new Map();
const processedStarts = new Set();

// –¢–µ–∫—Å—Ç—ã –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–∞—Ö
const texts = {
  russian: {
    welcome: 'üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ SkiSchool.ge Bot!',
    chooseLanguage: 'üåç –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫:',
    newOrder: 'üÜï –ù–û–í–´–ô –ó–ê–ö–ê–ó #',
    orderDetails: '–î–µ—Ç–∞–ª–∏ –∑–∞–∫–∞–∑–∞:',
    takeOrder: '‚úÖ –ë–ï–†–£ –°–ï–ë–ï',
    shareOrder: 'üîÑ –ü–ï–†–ï–î–ê–¢–¨ –ò–ù–°–¢–†–£–ö–¢–û–†–ê–ú', 
    deleteOrder: '‚ùå –£–î–ê–õ–ò–¢–¨',
    orderTaken: '‚úÖ –í–´ –í–ó–Ø–õ–ò –ó–ê–ö–ê–ó –°–ï–ë–ï',
    orderShared: 'üîÑ –ó–ê–ö–ê–ó –ü–ï–†–ï–î–ê–ù –ò–ù–°–¢–†–£–ö–¢–û–†–ê–ú',
    orderDeleted: '‚ùå –ó–ê–ö–ê–ó –£–î–ê–õ–ï–ù',
    availableOrder: 'üÜï –î–û–°–¢–£–ü–ï–ù –ó–ê–ö–ê–ó #',
    takeThisOrder: '‚úÖ –ë–ï–†–£ –ó–ê–ö–ê–ó',
    orderAccepted: '‚úÖ –í–´ –ü–†–ò–ù–Ø–õ–ò –ó–ê–ö–ê–ó #',
    contactClient: '‚ö†Ô∏è –°–≤—è–∂–∏—Ç–µ—Å—å —Å –∫–ª–∏–µ–Ω—Ç–æ–º –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è!',
    instructors: 'üë• –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã',
    stats: 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞',
    orders: 'üìã –ó–∞–∫–∞–∑—ã',
    addInstructor: '‚ûï –î–æ–±–∞–≤–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞',
    notAuthorized: '‚ùå –ù–ï –ê–í–¢–û–†–ò–ó–û–í–ê–ù\n\n–í—ã –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–≥–æ –±–æ—Ç–∞. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞.',
    notInstructor: '‚ùå –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.',
    orderAlreadyTaken: '‚ùå –≠—Ç–æ—Ç –∑–∞–∫–∞–∑ —É–∂–µ –≤–∑—è—Ç –¥—Ä—É–≥–∏–º –∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–º',
    welcomeInstructor: 'üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Å–∏—Å—Ç–µ–º—É SkiSchool.ge!',
    welcomeAdmin: 'ü§ñ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ SkiSchool.ge Admin Bot!'
  },
  english: {
    welcome: 'üëã Welcome to SkiSchool.ge Bot!',
    chooseLanguage: 'üåç Choose language:',
    newOrder: 'üÜï NEW ORDER #',
    orderDetails: 'Order details:',
    takeOrder: '‚úÖ TAKE FOR MYSELF',
    shareOrder: 'üîÑ SHARE WITH INSTRUCTORS',
    deleteOrder: '‚ùå DELETE',
    orderTaken: '‚úÖ YOU TOOK THE ORDER',
    orderShared: 'üîÑ ORDER SHARED WITH INSTRUCTORS',
    orderDeleted: '‚ùå ORDER DELETED',
    availableOrder: 'üÜï AVAILABLE ORDER #',
    takeThisOrder: '‚úÖ TAKE THIS ORDER',
    orderAccepted: '‚úÖ YOU ACCEPTED ORDER #',
    contactClient: '‚ö†Ô∏è Contact the client as soon as possible!',
    instructors: 'üë• Instructors',
    stats: 'üìä Statistics',
    orders: 'üìã Orders',
    addInstructor: '‚ûï Add instructor',
    notAuthorized: '‚ùå NOT AUTHORIZED\n\nYou are not authorized to use this bot. Contact administrator for access.',
    notInstructor: '‚ùå You are not registered as instructor. Contact administrator.',
    orderAlreadyTaken: '‚ùå This order was already taken by another instructor',
    welcomeInstructor: 'üëã Welcome to SkiSchool.ge system!',
    welcomeAdmin: 'ü§ñ Welcome to SkiSchool.ge Admin Bot!'
  }
};

// ==================== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ====================

// –ü–æ–ª—É—á–∏—Ç—å chat_id –∞–¥–º–∏–Ω–∞ –ø–æ username
async function getAdminChatIds() {
  try {
    const [admins] = await pool.execute(
      'SELECT telegram_username FROM instructors WHERE is_admin = true AND is_active = true'
    );
    
    const chatIds = [];
    // –í —Ä–µ–∞–ª—å–Ω–æ–º —Å—Ü–µ–Ω–∞—Ä–∏–∏ –Ω—É–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å chat_id –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    // –ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –∏–ª–∏ –∏—â–µ–º –¥—Ä—É–≥–∏–º–∏ —Å–ø–æ—Å–æ–±–∞–º–∏
    
    return chatIds;
  } catch (error) {
    console.error('Error getting admin chat IDs:', error);
    return [];
  }
}

// –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤—Å–µ–º –∞–¥–º–∏–Ω–∞–º
async function notifyAdmins(message) {
  try {
    console.log('üì¢ Sending notification to admins:', message);
    
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –∞–¥–º–∏–Ω–æ–≤
    const [admins] = await pool.execute(
      'SELECT telegram_username FROM instructors WHERE is_admin = true AND is_active = true'
    );
    
    if (admins.length === 0) {
      console.log('‚ùå No active admins found for notification');
      return;
    }

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É/–∫–∞–Ω–∞–ª –∞–¥–º–∏–Ω–æ–≤
    // –ó–∞–º–µ–Ω–∏—Ç–µ CHAT_ID –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π ID —á–∞—Ç–∞/–∫–∞–Ω–∞–ª–∞ –∞–¥–º–∏–Ω–æ–≤
    const ADMIN_CHAT_ID = process.env.ADMIN_CHAT_ID || '-1001234567890'; // –ü—Ä–∏–º–µ—Ä ID –≥—Ä—É–ø–ø—ã
    
    if (ADMIN_CHAT_ID) {
      try {
        await bot.telegram.sendMessage(ADMIN_CHAT_ID, message, {
          parse_mode: 'HTML',
          reply_markup: {
            inline_keyboard: [
              [
                { text: 'üìã –ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –∑–∞–∫–∞–∑—ã', callback_data: 'view_orders' },
                { text: 'üë• –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã', callback_data: 'view_instructors' }
              ]
            ]
          }
        });
        console.log('‚úÖ Notification sent to admin chat');
      } catch (error) {
        console.error('‚ùå Error sending notification to admin chat:', error);
      }
    }

    // –¢–∞–∫–∂–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –∫–∞–∂–¥–æ–º—É –∞–¥–º–∏–Ω—É
    for (const admin of admins) {
      try {
        // –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username (—ç—Ç–æ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ Telegram Bot API)
        // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –Ω—É–∂–Ω–æ —Ö—Ä–∞–Ω–∏—Ç—å chat_id –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        console.log(`üì® Would send notification to: ${admin.telegram_username}`);
      } catch (error) {
        console.error(`‚ùå Error notifying admin ${admin.telegram_username}:`, error);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Error in notifyAdmins:', error);
  }
}

// –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
async function isAuthorizedUser(username) {
  if (!isDatabaseInitialized) {
    console.log('‚ùå Database not initialized yet');
    return { authorized: false };
  }
  
  try {
    if (!username) {
      return { authorized: false };
    }
    
    const formattedUsername = username.startsWith('@') ? username : `@${username}`;
    
    const [rows] = await pool.execute(
      `SELECT * FROM instructors WHERE telegram_username = ? AND is_active = true`,
      [formattedUsername]
    );
    
    if (rows.length === 0) {
      return { authorized: false };
    }
    
    const instructor = rows[0];
    return { 
      authorized: true, 
      instructor,
      isAdmin: instructor.is_admin 
    };
  } catch (error) {
    console.error('Database error in isAuthorizedUser:', error);
    return { authorized: false };
  }
}

// –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
function getText(language) {
  return texts[language] || texts.russian;
}

// ==================== –û–°–ù–û–í–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò ====================

// –ö–æ–º–∞–Ω–¥–∞ —Å—Ç–∞—Ä—Ç - –ø—Ä–æ–≤–µ—Ä–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
bot.start(async (ctx) => {
  const username = ctx.from.username;
  const userId = ctx.from.id;
  const messageId = ctx.message.message_id;
  
  const startKey = `${userId}_${messageId}`;
  if (processedStarts.has(startKey)) {
    console.log('Duplicate start command ignored:', startKey);
    return;
  }
  
  processedStarts.add(startKey);
  setTimeout(() => {
    processedStarts.delete(startKey);
  }, 5000);
  
  console.log('User started bot:', username, 'ID:', userId, 'Message:', messageId);
  
  if (!username) {
    return ctx.reply(
      '‚ùå –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º Telegram username. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ username –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö Telegram.\n\n' +
      '‚ùå Telegram username is required to use this bot. Please set username in Telegram settings.'
    );
  }
  
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized) {
    return ctx.reply(
      texts.russian.notAuthorized + '\n\n' + texts.english.notAuthorized,
      { parse_mode: 'HTML' }
    );
  }
  
  // –°–æ—Ö—Ä–∞–Ω—è–µ–º chat_id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –±–∞–∑–µ –¥–ª—è –±—É–¥—É—â–∏—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
  try {
    await pool.execute(
      'UPDATE instructors SET telegram_chat_id = ? WHERE telegram_username = ?',
      [ctx.chat.id, auth.instructor.telegram_username]
    );
  } catch (error) {
    console.error('Error saving chat ID:', error);
  }
  
  if (auth.isAdmin) {
    console.log('Admin access granted to:', username);
    const t = getText(auth.instructor.language);
    ctx.reply(
      t.welcomeAdmin + '\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:',
      Markup.keyboard([
        ['üë• –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã', 'üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞'],
        ['üìã –ó–∞–∫–∞–∑—ã', '‚ûï –î–æ–±–∞–≤–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞']
      ]).resize()
    );
  } else {
    console.log('Instructor access granted to:', username);
    const currentLanguage = auth.instructor.language;
    const t = getText(currentLanguage);
    
    ctx.reply(
      t.welcomeInstructor,
      Markup.keyboard([
        [t.orders]
      ]).resize()
    );
  }
});

// ==================== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–ù–û–ü–û–ö –ê–î–ú–ò–ù–ê ====================

bot.hears('üë• –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã', async (ctx) => {
  console.log('üë• Instructors button clicked');
  const username = ctx.from.username;
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized || !auth.isAdmin) {
    return ctx.reply('‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω');
  }
  
  try {
    const [instructors] = await pool.execute(
      `SELECT * FROM instructors WHERE is_active = true ORDER BY name`
    );
    
    if (instructors.length === 0) {
      return ctx.reply('üì≠ –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤');
    }

    let message = `üë• –ê–ö–¢–ò–í–ù–´–ï –ò–ù–°–¢–†–£–ö–¢–û–†–´ (${instructors.length}):\n\n`;
    
    instructors.forEach((instructor, index) => {
      const role = instructor.is_admin ? 'üëë –ê–¥–º–∏–Ω' : 'üë§ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä';
      message += `${index + 1}. ${instructor.name || '–ë–µ–∑ –∏–º–µ–Ω–∏'} (${role})\n`;
      message += `   üë§ ${instructor.telegram_username}\n`;
      message += `   üåç ${instructor.language === 'english' ? 'English' : '–†—É—Å—Å–∫–∏–π'}\n`;
      message += `   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
    });

    ctx.reply(message, Markup.inlineKeyboard([
      [Markup.button.callback('üîÑ –û–±–Ω–æ–≤–∏—Ç—å', 'refresh_instructors')],
      [Markup.button.callback('üóëÔ∏è –£–¥–∞–ª–∏—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞', 'remove_instructor')]
    ]));
  } catch (error) {
    console.error('Database error:', error);
    ctx.reply('‚ùå –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
  }
});

bot.hears('üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', async (ctx) => {
  console.log('üìä Statistics button clicked');
  const username = ctx.from.username;
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized || !auth.isAdmin) {
    return ctx.reply('‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω');
  }

  try {
    const today = new Date().toISOString().split('T')[0];
    
    const [totalOrders] = await pool.execute('SELECT COUNT(*) as total_orders FROM orders');
    const [todayOrders] = await pool.execute(
      'SELECT COUNT(*) as today_orders FROM orders WHERE DATE(created_at) = ?',
      [today]
    );
    const [pendingOrders] = await pool.execute(
      "SELECT COUNT(*) as pending_orders FROM orders WHERE status = 'pending'"
    );
    const [activeInstructors] = await pool.execute(
      'SELECT COUNT(*) as active_instructors FROM instructors WHERE is_active = true'
    );
    
    const statsMessage = 
      `üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê –°–ò–°–¢–ï–ú–´\n\n` +
      `üì¶ –í—Å–µ–≥–æ –∑–∞–∫–∞–∑–æ–≤: ${totalOrders[0].total_orders}\n` +
      `üÜï –°–µ–≥–æ–¥–Ω—è: ${todayOrders[0].today_orders}\n` +
      `‚è≥ –û–∂–∏–¥–∞—é—Ç: ${pendingOrders[0].pending_orders}\n` +
      `üë• –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤: ${activeInstructors[0].active_instructors}`;

    ctx.reply(statsMessage);
  } catch (error) {
    console.error('Database error:', error);
    ctx.reply('‚ùå –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
  }
});

bot.hears('üìã –ó–∞–∫–∞–∑—ã', async (ctx) => {
  console.log('üìã Orders button clicked');
  const username = ctx.from.username;
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized) {
    return ctx.reply('‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω');
  }

  try {
    if (auth.isAdmin) {
      const [orders] = await pool.execute(
        `SELECT * FROM orders ORDER BY created_at DESC LIMIT 10`
      );
      
      if (!orders.length) {
        return ctx.reply('üì≠ –ù–µ—Ç –∑–∞–∫–∞–∑–æ–≤ –≤ —Å–∏—Å—Ç–µ–º–µ');
      }

      let message = `üìã –ü–û–°–õ–ï–î–ù–ò–ï –ó–ê–ö–ê–ó–´ (${orders.length}):\n\n`;
      
      orders.forEach((order, index) => {
        const statusIcons = {
          'pending': '‚è≥',
          'shared': 'üîÑ', 
          'taken_by_admin': '‚úÖ',
          'taken_by_instructor': 'üë§',
          'deleted': '‚ùå'
        };
        
        message += `${index + 1}. –ó–∞–∫–∞–∑ #${order.id} ${statusIcons[order.status] || 'üìù'}\n`;
        message += `   üéø ${order.sport_type} ‚Ä¢ ${order.participants} —á–µ–ª\n`;
        message += `   üìÖ ${order.date} ${order.time}\n`;
        message += `   üë§ ${order.client_name}\n`;
        message += `   üí∞ $${order.total_price}\n`;
        if (order.instructor_name) {
          message += `   üë§ –ò–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä: ${order.instructor_name}\n`;
        }
        message += `   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
      });

      ctx.reply(message);
    } else {
      const [orders] = await pool.execute(
        `SELECT * FROM orders WHERE status = 'shared' ORDER BY created_at DESC`
      );
      
      if (!orders.length) {
        const t = getText(auth.instructor.language);
        ctx.reply('üì≠ ' + (t === texts.english ? 'No available orders' : '–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤'));
        return;
      }

      const t = getText(auth.instructor.language);
      let message = t.language === 'english' ? 
        `üìã AVAILABLE ORDERS (${orders.length}):\n\n` :
        `üìã –î–û–°–¢–£–ü–ù–´–ï –ó–ê–ö–ê–ó–´ (${orders.length}):\n\n`;
      
      orders.forEach((order, index) => {
        message += `${index + 1}. ${t.availableOrder}${order.id}\n`;
        message += `   üéø ${order.sport_type} ‚Ä¢ ${getDurationText(order.duration, t.language)} ‚Ä¢ ${order.participants} ${t.language === 'english' ? 'people' : '—á–µ–ª'}\n`;
        message += `   üìÖ ${order.date} ‚Ä¢ ${order.time}\n`;
        message += `   üí∞ $${order.total_price}\n`;
        message += `   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
      });

      ctx.reply(message);
    }
  } catch (error) {
    console.error('Database error:', error);
    ctx.reply('‚ùå –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö');
  }
});

// ==================== –í–ï–ë–•–£–ö –î–õ–Ø –§–û–†–ú–´ ====================

app.post('/webhook/booking', cors(), async (req, res) => {
  if (!isDatabaseInitialized) {
    return res.status(503).json({ success: false, error: 'Database not initialized' });
  }
  
  try {
    const order = req.body;
    console.log('New booking received:', order.bookingId);
    
    if (!order.paymentStatus || order.paymentStatus !== 'completed') {
      return res.json({ success: false, error: 'Order not paid' });
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∑–∞–∫–∞–∑ –≤ –±–∞–∑—É MySQL
    const [result] = await pool.execute(
      `INSERT INTO orders 
        (client_name, phone, email, age, skill_level, additional_info, sport_type, duration, participants, days, date, time, total_price, deposit_price, remaining_price, booking_id) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        order.fullName, 
        order.phone, 
        order.email, 
        order.age, 
        order.skillLevel,
        order.additionalInfo,
        order.sport, 
        order.duration, 
        order.participants, 
        order.days, 
        order.date, 
        order.time, 
        order.total, 
        order.deposit,
        order.remaining,
        order.bookingId
      ]
    );
    
    const orderId = result.insertId;
    console.log('Order saved with ID:', orderId);
    
    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –∞–¥–º–∏–Ω–∞
    const adminMessage = 
      `üÜï <b>–ù–û–í–´–ô –ó–ê–ö–ê–ó #${orderId}</b>\n` +
      `üìã <b>ID –±—Ä–æ–Ω–∏:</b> ${order.bookingId}\n` +
      `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n` +
      `üéø <b>${order.sport === 'ski' ? '–õ—ã–∂–∏' : order.sport === 'snowboard' ? '–°–Ω–æ—É–±–æ—Ä–¥' : '–î–µ—Ç—Å–∫–∏–π –∫–ª—É–±'}</b> ‚Ä¢ ${getDurationText(order.duration, 'russian')} ‚Ä¢ ${order.participants} —á–µ–ª ‚Ä¢ ${order.days} –¥–Ω.\n` +
      `üìÖ <b>${order.date}</b> ‚Ä¢ ${order.time}\n` +
      `üë§ <b>${order.fullName}</b>\n` +
      `üìû <b>${order.phone}</b>\n` +
      `üìß <b>${order.email}</b>\n` +
      `üéØ <b>–£—Ä–æ–≤–µ–Ω—å:</b> ${getSkillLevelText(order.skillLevel, 'russian')}\n` +
      `üë∂ <b>–í–æ–∑—Ä–∞—Å—Ç:</b> ${order.age}\n` +
      `üí¨ <b>–î–æ–ø. –∏–Ω—Ñ–æ:</b> ${order.additionalInfo || '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}\n` +
      `üí∞ <b>–°—Ç–æ–∏–º–æ—Å—Ç—å:</b> $${order.total} (–¥–µ–ø–æ–∑–∏—Ç: $${order.deposit}, –æ—Å—Ç–∞—Ç–æ–∫: $${order.remaining})\n` +
      `‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n` +
      `‚è∞ <i>–ó–∞–∫–∞–∑ –æ–∂–∏–¥–∞–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∏–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–∞</i>`;

    // –û–¢–ü–†–ê–í–õ–Ø–ï–ú –£–í–ï–î–û–ú–õ–ï–ù–ò–ï –ê–î–ú–ò–ù–ê–ú
    await notifyAdmins(adminMessage);
    
    console.log('‚úÖ Order saved and admins notified');
    
    res.json({ success: true, orderId });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ç–µ–∫—Å—Ç–∞
function getDurationText(duration, language) {
  const durations = {
    '2': language === 'english' ? '2 hours' : '2 —á–∞—Å–∞',
    '3': language === 'english' ? '3 hours' : '3 —á–∞—Å–∞', 
    'full': language === 'english' ? 'Full day' : '–ü–æ–ª–Ω—ã–π –¥–µ–Ω—å',
    'half-lunch': language === 'english' ? 'Half day with lunch' : '–ü–æ–ª–¥–Ω—è —Å –æ–±–µ–¥–æ–º',
    'half-nolunch': language === 'english' ? 'Half day no lunch' : '–ü–æ–ª–¥–Ω—è –±–µ–∑ –æ–±–µ–¥–∞'
  };
  return durations[duration] || duration;
}

function getSkillLevelText(level, language) {
  const levels = {
    'first-time': language === 'english' ? 'First Time' : '–ü–µ—Ä–≤—ã–π —Ä–∞–∑',
    'beginner': language === 'english' ? 'Beginner' : '–ù–∞—á–∏–Ω–∞—é—â–∏–π',
    'intermediate': language === 'english' ? 'Intermediate' : '–°—Ä–µ–¥–Ω–∏–π',
    'advanced': language === 'english' ? 'Advanced' : '–ü—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π'
  };
  return levels[level] || level;
}

// ==================== WEB SERVER ROUTES ====================

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π —Ñ–∞–π–ª —Ñ–æ—Ä–º—ã
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Health check endpoint
app.get('/health', async (req, res) => {
  try {
    if (!isDatabaseInitialized) {
      return res.status(503).json({ 
        status: 'ERROR', 
        database: 'initializing',
        message: 'Database is initializing, please wait...' 
      });
    }
    
    await pool.execute('SELECT 1');
    res.json({ 
      status: 'OK', 
      database: 'connected',
      initialized: isDatabaseInitialized,
      timestamp: new Date().toISOString() 
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      database: 'disconnected',
      error: error.message 
    });
  }
});

// –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
bot.launch().then(() => {
  console.log('ü§ñ SkiSchool.ge Bot –∑–∞–ø—É—â–µ–Ω!');
  console.log('üëë –ê–¥–º–∏–Ω:', ADMIN_USERNAME);
  console.log('ü§ñ –ë–æ—Ç: @skischoolge_bot');
  console.log('üóÑÔ∏è –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: MySQL on Railway');
}).catch(err => {
  console.error('Error launching bot:', err);
});

// –ó–∞–ø—É—Å–∫ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
const PORT = process.env.PORT || 3000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`üöÄ Web server running on port ${PORT}`);
  console.log(`üåê Health check: http://localhost:${PORT}/health`);
  console.log(`üì® Webhook URL: https://skischoolgebot-production.up.railway.app/webhook/booking`);
});

// Graceful shutdown
process.once('SIGINT', () => {
  console.log('Shutting down gracefully...');
  bot.stop('SIGINT');
  if (pool) pool.end();
});

process.once('SIGTERM', () => {
  console.log('Shutting down gracefully...');
  bot.stop('SIGTERM');
  if (pool) pool.end();
});
