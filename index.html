const { Telegraf, Markup } = require('telegraf');
const mysql = require('mysql2/promise');
const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ MySQL Ğ´Ğ»Ñ Railway
let pool;
let isDatabaseInitialized = false;

async function initializeDatabase() {
  try {
    console.log('ğŸ”„ Initializing MySQL connection...');
    
    const dbConfig = {
      host: process.env.MYSQLHOST || 'localhost',
      port: process.env.MYSQLPORT || 3306,
      user: process.env.MYSQLUSER || 'root',
      password: process.env.MYSQLPASSWORD || '',
      database: process.env.MYSQLDATABASE || 'railway',
      waitForConnections: true,
      connectionLimit: 10,
      queueLimit: 0,
      ...(process.env.NODE_ENV === 'production' && {
        ssl: { rejectUnauthorized: false }
      })
    };

    console.log('ğŸ“Š MySQL Config:', {
      host: dbConfig.host,
      port: dbConfig.port,
      user: dbConfig.user,
      database: dbConfig.database
    });

    pool = mysql.createPool(dbConfig);

    const connection = await pool.getConnection();
    console.log('âœ… Connected to MySQL database');
    connection.release();

    await createTables();
    isDatabaseInitialized = true;
    console.log('ğŸ‰ Database initialization completed successfully!');
    
  } catch (error) {
    console.error('âŒ Database initialization error:', error);
    console.log('ğŸ”„ Retrying in 10 seconds...');
    setTimeout(initializeDatabase, 10000);
  }
}

async function createTables() {
  try {
    console.log('ğŸ”„ Creating tables...');
    
    await pool.execute(`
      CREATE TABLE IF NOT EXISTS instructors (
        id INT AUTO_INCREMENT PRIMARY KEY,
        name VARCHAR(255),
        telegram_username VARCHAR(255) UNIQUE NOT NULL,
        language VARCHAR(50) DEFAULT 'russian',
        is_active BOOLEAN DEFAULT true,
        is_admin BOOLEAN DEFAULT false,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      ) ENGINE=InnoDB CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci
    `);
    console.log('âœ… instructors table ready');

    await pool.execute(`
      CREATE TABLE IF NOT EXISTS orders (
        id INT AUTO_INCREMENT PRIMARY KEY,
        client_name VARCHAR(255) NOT NULL,
        phone VARCHAR(100) NOT NULL,
        email VARCHAR(255) NOT NULL,
        age INT NOT NULL,
        skill_level VARCHAR(100),
        additional_info TEXT,
        sport_type VARCHAR(100) NOT NULL,
        duration VARCHAR(50) NOT NULL,
        participants INT NOT NULL,
        days INT NOT NULL,
        date DATE NOT NULL,
        time TIME NOT NULL,
        total_price INT NOT NULL,
        deposit_price INT NOT NULL,
        remaining_price INT NOT NULL,
        status VARCHAR(50) DEFAULT 'pending',
        instructor_username VARCHAR(255),
        instructor_name VARCHAR(255),
        payment_status VARCHAR(50) DEFAULT 'completed',
        booking_id VARCHAR(100) UNIQUE NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      ) ENGINE=InnoDB CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci
    `);
    console.log('âœ… orders table ready');

    await initializeAdminUser();
    
  } catch (error) {
    console.error('âŒ Table creation error:', error);
    throw error;
  }
}

async function initializeAdminUser() {
  try {
    const ADMIN_USERNAME = process.env.ADMIN_USERNAME ? 
      (process.env.ADMIN_USERNAME.startsWith('@') ? process.env.ADMIN_USERNAME : `@${process.env.ADMIN_USERNAME}`) : 
      '@ski_meditation';

    console.log('ğŸ”„ Checking admin user:', ADMIN_USERNAME);

    const [adminRows] = await pool.execute(
      'SELECT COUNT(*) as count FROM instructors WHERE telegram_username = ?',
      [ADMIN_USERNAME]
    );

    if (adminRows[0].count === 0) {
      await pool.execute(
        `INSERT INTO instructors (name, telegram_username, language, is_admin) 
         VALUES (?, ?, ?, ?)`,
        ['Admin', ADMIN_USERNAME, 'russian', true]
      );
      console.log('âœ… Admin user created:', ADMIN_USERNAME);
    } else {
      await pool.execute(
        `UPDATE instructors SET is_admin = true, is_active = true WHERE telegram_username = ?`,
        [ADMIN_USERNAME]
      );
      console.log('âœ… Admin user updated:', ADMIN_USERNAME);
    }
  } catch (error) {
    console.error('âŒ Admin user initialization error:', error);
  }
}

// ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ
const BOT_TOKEN = process.env.BOT_TOKEN || '8201481946:AAGpCm40p0ihCFccA-fAuFHFqMoseMb6OLc';
const ADMIN_USERNAME = process.env.ADMIN_USERNAME ? 
    (process.env.ADMIN_USERNAME.startsWith('@') ? process.env.ADMIN_USERNAME : `@${process.env.ADMIN_USERNAME}`) : 
    '@ski_meditation';

console.log('ğŸ¤– Starting SkiSchool.ge Bot...');
console.log('ğŸ‘‘ Admin username:', ADMIN_USERNAME);

// Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ Ğ±Ğ°Ğ·Ñƒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ğµ
initializeDatabase();

const bot = new Telegraf(BOT_TOKEN);

// Ğ¥Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ Ğ´Ğ»Ñ ÑĞ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğ¹
const userStates = new Map();
const processedStarts = new Set();

// Ğ¢ĞµĞºÑÑ‚Ñ‹ Ğ½Ğ° Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… ÑĞ·Ñ‹ĞºĞ°Ñ…
const texts = {
  russian: {
    welcome: 'ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² SkiSchool.ge Bot!',
    chooseLanguage: 'ğŸŒ Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ·Ñ‹Ğº:',
    newOrder: 'ğŸ†• ĞĞĞ’Ğ«Ğ™ Ğ—ĞĞšĞĞ— #',
    orderDetails: 'Ğ”ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ°:',
    takeOrder: 'âœ… Ğ‘Ğ•Ğ Ğ£ Ğ¡Ğ•Ğ‘Ğ•',
    shareOrder: 'ğŸ”„ ĞŸĞ•Ğ Ğ•Ğ”ĞĞ¢Ğ¬ Ğ˜ĞĞ¡Ğ¢Ğ Ğ£ĞšĞ¢ĞĞ ĞĞœ', 
    deleteOrder: 'âŒ Ğ£Ğ”ĞĞ›Ğ˜Ğ¢Ğ¬',
    orderTaken: 'âœ… Ğ’Ğ« Ğ’Ğ—Ğ¯Ğ›Ğ˜ Ğ—ĞĞšĞĞ— Ğ¡Ğ•Ğ‘Ğ•',
    orderShared: 'ğŸ”„ Ğ—ĞĞšĞĞ— ĞŸĞ•Ğ Ğ•Ğ”ĞĞ Ğ˜ĞĞ¡Ğ¢Ğ Ğ£ĞšĞ¢ĞĞ ĞĞœ',
    orderDeleted: 'âŒ Ğ—ĞĞšĞĞ— Ğ£Ğ”ĞĞ›Ğ•Ğ',
    availableOrder: 'ğŸ†• Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞ•Ğ Ğ—ĞĞšĞĞ— #',
    takeThisOrder: 'âœ… Ğ‘Ğ•Ğ Ğ£ Ğ—ĞĞšĞĞ—',
    orderAccepted: 'âœ… Ğ’Ğ« ĞŸĞ Ğ˜ĞĞ¯Ğ›Ğ˜ Ğ—ĞĞšĞĞ— #',
    contactClient: 'âš ï¸ Ğ¡Ğ²ÑĞ¶Ğ¸Ñ‚ĞµÑÑŒ Ñ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ¼ Ğ² Ğ±Ğ»Ğ¸Ğ¶Ğ°Ğ¹ÑˆĞµĞµ Ğ²Ñ€ĞµĞ¼Ñ!',
    instructors: 'ğŸ‘¥ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹',
    stats: 'ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
    orders: 'ğŸ“‹ Ğ—Ğ°ĞºĞ°Ğ·Ñ‹',
    addInstructor: 'â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ°',
    notAuthorized: 'âŒ ĞĞ• ĞĞ’Ğ¢ĞĞ Ğ˜Ğ—ĞĞ’ĞĞ\n\nĞ’Ñ‹ Ğ½Ğµ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ñ‹ Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ÑÑ‚Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ñ‚Ğ°. ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚ĞµÑÑŒ Ğº Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñƒ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°.',
    notInstructor: 'âŒ Ğ’Ñ‹ Ğ½Ğµ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ñ‹ ĞºĞ°Ğº Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€. ĞĞ±Ñ€Ğ°Ñ‚Ğ¸Ñ‚ĞµÑÑŒ Ğº Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€Ñƒ.',
    orderAlreadyTaken: 'âŒ Ğ­Ñ‚Ğ¾Ñ‚ Ğ·Ğ°ĞºĞ°Ğ· ÑƒĞ¶Ğµ Ğ²Ğ·ÑÑ‚ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ¾Ğ¼',
    welcomeInstructor: 'ğŸ‘‹ Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ñƒ SkiSchool.ge!',
    welcomeAdmin: 'ğŸ¤– Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ğ² SkiSchool.ge Admin Bot!'
  },
  english: {
    welcome: 'ğŸ‘‹ Welcome to SkiSchool.ge Bot!',
    chooseLanguage: 'ğŸŒ Choose language:',
    newOrder: 'ğŸ†• NEW ORDER #',
    orderDetails: 'Order details:',
    takeOrder: 'âœ… TAKE FOR MYSELF',
    shareOrder: 'ğŸ”„ SHARE WITH INSTRUCTORS',
    deleteOrder: 'âŒ DELETE',
    orderTaken: 'âœ… YOU TOOK THE ORDER',
    orderShared: 'ğŸ”„ ORDER SHARED WITH INSTRUCTORS',
    orderDeleted: 'âŒ ORDER DELETED',
    availableOrder: 'ğŸ†• AVAILABLE ORDER #',
    takeThisOrder: 'âœ… TAKE THIS ORDER',
    orderAccepted: 'âœ… YOU ACCEPTED ORDER #',
    contactClient: 'âš ï¸ Contact the client as soon as possible!',
    instructors: 'ğŸ‘¥ Instructors',
    stats: 'ğŸ“Š Statistics',
    orders: 'ğŸ“‹ Orders',
    addInstructor: 'â• Add instructor',
    notAuthorized: 'âŒ NOT AUTHORIZED\n\nYou are not authorized to use this bot. Contact administrator for access.',
    notInstructor: 'âŒ You are not registered as instructor. Contact administrator.',
    orderAlreadyTaken: 'âŒ This order was already taken by another instructor',
    welcomeInstructor: 'ğŸ‘‹ Welcome to SkiSchool.ge system!',
    welcomeAdmin: 'ğŸ¤– Welcome to SkiSchool.ge Admin Bot!'
  }
};

// ==================== Ğ’Ğ¡ĞŸĞĞœĞĞ“ĞĞ¢Ğ•Ğ›Ğ¬ĞĞ«Ğ• Ğ¤Ğ£ĞĞšĞ¦Ğ˜Ğ˜ ====================

// ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ chat_id Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ° Ğ¿Ğ¾ username
async function getAdminChatIds() {
  try {
    const [admins] = await pool.execute(
      'SELECT telegram_username FROM instructors WHERE is_admin = true AND is_active = true'
    );
    
    const chatIds = [];
    // Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ chat_id Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…
    // ĞŸĞ¾ĞºĞ° Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ğ´ĞµÑ„Ğ¾Ğ»Ñ‚Ğ½Ñ‹Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ğ¸Ñ‰ĞµĞ¼ Ğ´Ñ€ÑƒĞ³Ğ¸Ğ¼Ğ¸ ÑĞ¿Ğ¾ÑĞ¾Ğ±Ğ°Ğ¼Ğ¸
    
    return chatIds;
  } catch (error) {
    console.error('Error getting admin chat IDs:', error);
    return [];
  }
}

// ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğµ Ğ²ÑĞµĞ¼ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°Ğ¼
async function notifyAdmins(message) {
  try {
    console.log('ğŸ“¢ Sending notification to admins:', message);
    
    // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ²ÑĞµÑ… Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²
    const [admins] = await pool.execute(
      'SELECT telegram_username FROM instructors WHERE is_admin = true AND is_active = true'
    );
    
    if (admins.length === 0) {
      console.log('âŒ No active admins found for notification');
      return;
    }

    // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ² Ğ³Ñ€ÑƒĞ¿Ğ¿Ñƒ/ĞºĞ°Ğ½Ğ°Ğ» Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²
    // Ğ—Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚Ğµ CHAT_ID Ğ½Ğ° Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ID Ñ‡Ğ°Ñ‚Ğ°/ĞºĞ°Ğ½Ğ°Ğ»Ğ° Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ¾Ğ²
    const ADMIN_CHAT_ID = process.env.ADMIN_CHAT_ID || '-1001234567890'; // ĞŸÑ€Ğ¸Ğ¼ĞµÑ€ ID Ğ³Ñ€ÑƒĞ¿Ğ¿Ñ‹
    
    if (ADMIN_CHAT_ID) {
      try {
        await bot.telegram.sendMessage(ADMIN_CHAT_ID, message, {
          parse_mode: 'HTML',
          reply_markup: {
            inline_keyboard: [
              [
                { text: 'ğŸ“‹ ĞŸĞ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹', callback_data: 'view_orders' },
                { text: 'ğŸ‘¥ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹', callback_data: 'view_instructors' }
              ]
            ]
          }
        });
        console.log('âœ… Notification sent to admin chat');
      } catch (error) {
        console.error('âŒ Error sending notification to admin chat:', error);
      }
    }

    // Ğ¢Ğ°ĞºĞ¶Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ¼Ñƒ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ñƒ
    for (const admin of admins) {
      try {
        // Ğ˜Ñ‰ĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ¿Ğ¾ username (ÑÑ‚Ğ¾ Ğ¾Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ‡ĞµĞ½Ğ¸Ğµ Telegram Bot API)
        // Ğ’ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ğ¸ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ chat_id ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
        console.log(`ğŸ“¨ Would send notification to: ${admin.telegram_username}`);
      } catch (error) {
        console.error(`âŒ Error notifying admin ${admin.telegram_username}:`, error);
      }
    }
    
  } catch (error) {
    console.error('âŒ Error in notifyAdmins:', error);
  }
}

// ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
async function isAuthorizedUser(username) {
  if (!isDatabaseInitialized) {
    console.log('âŒ Database not initialized yet');
    return { authorized: false };
  }
  
  try {
    if (!username) {
      return { authorized: false };
    }
    
    const formattedUsername = username.startsWith('@') ? username : `@${username}`;
    
    const [rows] = await pool.execute(
      `SELECT * FROM instructors WHERE telegram_username = ? AND is_active = true`,
      [formattedUsername]
    );
    
    if (rows.length === 0) {
      return { authorized: false };
    }
    
    const instructor = rows[0];
    return { 
      authorized: true, 
      instructor,
      isAdmin: instructor.is_admin 
    };
  } catch (error) {
    console.error('Database error in isAuthorizedUser:', error);
    return { authorized: false };
  }
}

// ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ‚ĞµĞºÑÑ‚ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
function getText(language) {
  return texts[language] || texts.russian;
}

// ==================== ĞĞ¡ĞĞĞ’ĞĞ«Ğ• ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ ====================

// ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° ÑÑ‚Ğ°Ñ€Ñ‚ - Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸ Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ¾Ğ¹ Ğ¾Ñ‚ Ğ´ÑƒĞ±Ğ»Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ
bot.start(async (ctx) => {
  const username = ctx.from.username;
  const userId = ctx.from.id;
  const messageId = ctx.message.message_id;
  
  const startKey = `${userId}_${messageId}`;
  if (processedStarts.has(startKey)) {
    console.log('Duplicate start command ignored:', startKey);
    return;
  }
  
  processedStarts.add(startKey);
  setTimeout(() => {
    processedStarts.delete(startKey);
  }, 5000);
  
  console.log('User started bot:', username, 'ID:', userId, 'Message:', messageId);
  
  if (!username) {
    return ctx.reply(
      'âŒ Ğ”Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ±Ğ¾Ñ‚Ğ° Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Telegram username. ĞŸĞ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ°, ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ¸Ñ‚Ğµ username Ğ² Ğ½Ğ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ°Ñ… Telegram.\n\n' +
      'âŒ Telegram username is required to use this bot. Please set username in Telegram settings.'
    );
  }
  
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized) {
    return ctx.reply(
      texts.russian.notAuthorized + '\n\n' + texts.english.notAuthorized,
      { parse_mode: 'HTML' }
    );
  }
  
  // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ chat_id Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ Ğ² Ğ±Ğ°Ğ·Ğµ Ğ´Ğ»Ñ Ğ±ÑƒĞ´ÑƒÑ‰Ğ¸Ñ… ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹
  try {
    await pool.execute(
      'UPDATE instructors SET telegram_chat_id = ? WHERE telegram_username = ?',
      [ctx.chat.id, auth.instructor.telegram_username]
    );
  } catch (error) {
    console.error('Error saving chat ID:', error);
  }
  
  if (auth.isAdmin) {
    console.log('Admin access granted to:', username);
    const t = getText(auth.instructor.language);
    ctx.reply(
      t.welcomeAdmin + '\n\nĞ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ:',
      Markup.keyboard([
        ['ğŸ‘¥ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹', 'ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°'],
        ['ğŸ“‹ Ğ—Ğ°ĞºĞ°Ğ·Ñ‹', 'â• Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ°']
      ]).resize()
    );
  } else {
    console.log('Instructor access granted to:', username);
    const currentLanguage = auth.instructor.language;
    const t = getText(currentLanguage);
    
    ctx.reply(
      t.welcomeInstructor,
      Markup.keyboard([
        [t.orders]
      ]).resize()
    );
  }
});

// ==================== ĞĞ‘Ğ ĞĞ‘ĞĞ¢Ğ§Ğ˜ĞšĞ˜ ĞšĞĞĞŸĞĞš ĞĞ”ĞœĞ˜ĞĞ ====================

bot.hears('ğŸ‘¥ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ñ‹', async (ctx) => {
  console.log('ğŸ‘¥ Instructors button clicked');
  const username = ctx.from.username;
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized || !auth.isAdmin) {
    return ctx.reply('âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½');
  }
  
  try {
    const [instructors] = await pool.execute(
      `SELECT * FROM instructors WHERE is_active = true ORDER BY name`
    );
    
    if (instructors.length === 0) {
      return ctx.reply('ğŸ“­ ĞĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ¾Ğ²');
    }

    let message = `ğŸ‘¥ ĞĞšĞ¢Ğ˜Ğ’ĞĞ«Ğ• Ğ˜ĞĞ¡Ğ¢Ğ Ğ£ĞšĞ¢ĞĞ Ğ« (${instructors.length}):\n\n`;
    
    instructors.forEach((instructor, index) => {
      const role = instructor.is_admin ? 'ğŸ‘‘ ĞĞ´Ğ¼Ğ¸Ğ½' : 'ğŸ‘¤ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€';
      message += `${index + 1}. ${instructor.name || 'Ğ‘ĞµĞ· Ğ¸Ğ¼ĞµĞ½Ğ¸'} (${role})\n`;
      message += `   ğŸ‘¤ ${instructor.telegram_username}\n`;
      message += `   ğŸŒ ${instructor.language === 'english' ? 'English' : 'Ğ ÑƒÑÑĞºĞ¸Ğ¹'}\n`;
      message += `   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
    });

    ctx.reply(message, Markup.inlineKeyboard([
      [Markup.button.callback('ğŸ”„ ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ', 'refresh_instructors')],
      [Markup.button.callback('ğŸ—‘ï¸ Ğ£Ğ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ°', 'remove_instructor')]
    ]));
  } catch (error) {
    console.error('Database error:', error);
    ctx.reply('âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…');
  }
});

bot.hears('ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°', async (ctx) => {
  console.log('ğŸ“Š Statistics button clicked');
  const username = ctx.from.username;
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized || !auth.isAdmin) {
    return ctx.reply('âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½');
  }

  try {
    const today = new Date().toISOString().split('T')[0];
    
    const [totalOrders] = await pool.execute('SELECT COUNT(*) as total_orders FROM orders');
    const [todayOrders] = await pool.execute(
      'SELECT COUNT(*) as today_orders FROM orders WHERE DATE(created_at) = ?',
      [today]
    );
    const [pendingOrders] = await pool.execute(
      "SELECT COUNT(*) as pending_orders FROM orders WHERE status = 'pending'"
    );
    const [activeInstructors] = await pool.execute(
      'SELECT COUNT(*) as active_instructors FROM instructors WHERE is_active = true'
    );
    
    const statsMessage = 
      `ğŸ“Š Ğ¡Ğ¢ĞĞ¢Ğ˜Ğ¡Ğ¢Ğ˜ĞšĞ Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞ«\n\n` +
      `ğŸ“¦ Ğ’ÑĞµĞ³Ğ¾ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²: ${totalOrders[0].total_orders}\n` +
      `ğŸ†• Ğ¡ĞµĞ³Ğ¾Ğ´Ğ½Ñ: ${todayOrders[0].today_orders}\n` +
      `â³ ĞĞ¶Ğ¸Ğ´Ğ°ÑÑ‚: ${pendingOrders[0].pending_orders}\n` +
      `ğŸ‘¥ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ¾Ğ²: ${activeInstructors[0].active_instructors}`;

    ctx.reply(statsMessage);
  } catch (error) {
    console.error('Database error:', error);
    ctx.reply('âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…');
  }
});

bot.hears('ğŸ“‹ Ğ—Ğ°ĞºĞ°Ğ·Ñ‹', async (ctx) => {
  console.log('ğŸ“‹ Orders button clicked');
  const username = ctx.from.username;
  const auth = await isAuthorizedUser(username);
  
  if (!auth.authorized) {
    return ctx.reply('âŒ Ğ”Ğ¾ÑÑ‚ÑƒĞ¿ Ğ·Ğ°Ğ¿Ñ€ĞµÑ‰ĞµĞ½');
  }

  try {
    if (auth.isAdmin) {
      const [orders] = await pool.execute(
        `SELECT * FROM orders ORDER BY created_at DESC LIMIT 10`
      );
      
      if (!orders.length) {
        return ctx.reply('ğŸ“­ ĞĞµÑ‚ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ² Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ');
      }

      let message = `ğŸ“‹ ĞŸĞĞ¡Ğ›Ğ•Ğ”ĞĞ˜Ğ• Ğ—ĞĞšĞĞ—Ğ« (${orders.length}):\n\n`;
      
      orders.forEach((order, index) => {
        const statusIcons = {
          'pending': 'â³',
          'shared': 'ğŸ”„', 
          'taken_by_admin': 'âœ…',
          'taken_by_instructor': 'ğŸ‘¤',
          'deleted': 'âŒ'
        };
        
        message += `${index + 1}. Ğ—Ğ°ĞºĞ°Ğ· #${order.id} ${statusIcons[order.status] || 'ğŸ“'}\n`;
        message += `   ğŸ¿ ${order.sport_type} â€¢ ${order.participants} Ñ‡ĞµĞ»\n`;
        message += `   ğŸ“… ${order.date} ${order.time}\n`;
        message += `   ğŸ‘¤ ${order.client_name}\n`;
        message += `   ğŸ’° $${order.total_price}\n`;
        if (order.instructor_name) {
          message += `   ğŸ‘¤ Ğ˜Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€: ${order.instructor_name}\n`;
        }
        message += `   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      });

      ctx.reply(message);
    } else {
      const [orders] = await pool.execute(
        `SELECT * FROM orders WHERE status = 'shared' ORDER BY created_at DESC`
      );
      
      if (!orders.length) {
        const t = getText(auth.instructor.language);
        ctx.reply('ğŸ“­ ' + (t === texts.english ? 'No available orders' : 'ĞĞµÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ñ… Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²'));
        return;
      }

      const t = getText(auth.instructor.language);
      let message = t.language === 'english' ? 
        `ğŸ“‹ AVAILABLE ORDERS (${orders.length}):\n\n` :
        `ğŸ“‹ Ğ”ĞĞ¡Ğ¢Ğ£ĞŸĞĞ«Ğ• Ğ—ĞĞšĞĞ—Ğ« (${orders.length}):\n\n`;
      
      orders.forEach((order, index) => {
        message += `${index + 1}. ${t.availableOrder}${order.id}\n`;
        message += `   ğŸ¿ ${order.sport_type} â€¢ ${getDurationText(order.duration, t.language)} â€¢ ${order.participants} ${t.language === 'english' ? 'people' : 'Ñ‡ĞµĞ»'}\n`;
        message += `   ğŸ“… ${order.date} â€¢ ${order.time}\n`;
        message += `   ğŸ’° $${order.total_price}\n`;
        message += `   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n`;
      });

      ctx.reply(message);
    }
  } catch (error) {
    console.error('Database error:', error);
    ctx.reply('âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ±Ğ°Ğ·Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…');
  }
});

// ==================== Ğ’Ğ•Ğ‘Ğ¥Ğ£Ğš Ğ”Ğ›Ğ¯ Ğ¤ĞĞ ĞœĞ« ====================

app.post('/webhook/booking', cors(), async (req, res) => {
  if (!isDatabaseInitialized) {
    return res.status(503).json({ success: false, error: 'Database not initialized' });
  }
  
  try {
    const order = req.body;
    console.log('New booking received:', order.bookingId);
    
    if (!order.paymentStatus || order.paymentStatus !== 'completed') {
      return res.json({ success: false, error: 'Order not paid' });
    }
    
    // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ· Ğ² Ğ±Ğ°Ğ·Ñƒ MySQL
    const [result] = await pool.execute(
      `INSERT INTO orders 
        (client_name, phone, email, age, skill_level, additional_info, sport_type, duration, participants, days, date, time, total_price, deposit_price, remaining_price, booking_id) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        order.fullName, 
        order.phone, 
        order.email, 
        order.age, 
        order.skillLevel,
        order.additionalInfo,
        order.sport, 
        order.duration, 
        order.participants, 
        order.days, 
        order.date, 
        order.time, 
        order.total, 
        order.deposit,
        order.remaining,
        order.bookingId
      ]
    );
    
    const orderId = result.insertId;
    console.log('Order saved with ID:', orderId);
    
    // Ğ¤Ğ¾Ñ€Ğ¼Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ´Ğ»Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ğ°
    const adminMessage = 
      `ğŸ†• <b>ĞĞĞ’Ğ«Ğ™ Ğ—ĞĞšĞĞ— #${orderId}</b>\n` +
      `ğŸ“‹ <b>ID Ğ±Ñ€Ğ¾Ğ½Ğ¸:</b> ${order.bookingId}\n` +
      `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n` +
      `ğŸ¿ <b>${order.sport === 'ski' ? 'Ğ›Ñ‹Ğ¶Ğ¸' : order.sport === 'snowboard' ? 'Ğ¡Ğ½Ğ¾ÑƒĞ±Ğ¾Ñ€Ğ´' : 'Ğ”ĞµÑ‚ÑĞºĞ¸Ğ¹ ĞºĞ»ÑƒĞ±'}</b> â€¢ ${getDurationText(order.duration, 'russian')} â€¢ ${order.participants} Ñ‡ĞµĞ» â€¢ ${order.days} Ğ´Ğ½.\n` +
      `ğŸ“… <b>${order.date}</b> â€¢ ${order.time}\n` +
      `ğŸ‘¤ <b>${order.fullName}</b>\n` +
      `ğŸ“ <b>${order.phone}</b>\n` +
      `ğŸ“§ <b>${order.email}</b>\n` +
      `ğŸ¯ <b>Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ:</b> ${getSkillLevelText(order.skillLevel, 'russian')}\n` +
      `ğŸ‘¶ <b>Ğ’Ğ¾Ğ·Ñ€Ğ°ÑÑ‚:</b> ${order.age}\n` +
      `ğŸ’¬ <b>Ğ”Ğ¾Ğ¿. Ğ¸Ğ½Ñ„Ğ¾:</b> ${order.additionalInfo || 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ¾'}\n` +
      `ğŸ’° <b>Ğ¡Ñ‚Ğ¾Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ:</b> $${order.total} (Ğ´ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚: $${order.deposit}, Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ğº: $${order.remaining})\n` +
      `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n` +
      `â° <i>Ğ—Ğ°ĞºĞ°Ğ· Ğ¾Ğ¶Ğ¸Ğ´Ğ°ĞµÑ‚ Ğ½Ğ°Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ Ğ¸Ğ½ÑÑ‚Ñ€ÑƒĞºÑ‚Ğ¾Ñ€Ğ°</i>`;

    // ĞĞ¢ĞŸĞ ĞĞ’Ğ›Ğ¯Ğ•Ğœ Ğ£Ğ’Ğ•Ğ”ĞĞœĞ›Ğ•ĞĞ˜Ğ• ĞĞ”ĞœĞ˜ĞĞĞœ
    await notifyAdmins(adminMessage);
    
    console.log('âœ… Order saved and admins notified');
    
    res.json({ success: true, orderId });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ´Ğ»Ñ Ñ‚ĞµĞºÑÑ‚Ğ°
function getDurationText(duration, language) {
  const durations = {
    '2': language === 'english' ? '2 hours' : '2 Ñ‡Ğ°ÑĞ°',
    '3': language === 'english' ? '3 hours' : '3 Ñ‡Ğ°ÑĞ°', 
    'full': language === 'english' ? 'Full day' : 'ĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ´ĞµĞ½ÑŒ',
    'half-lunch': language === 'english' ? 'Half day with lunch' : 'ĞŸĞ¾Ğ»Ğ´Ğ½Ñ Ñ Ğ¾Ğ±ĞµĞ´Ğ¾Ğ¼',
    'half-nolunch': language === 'english' ? 'Half day no lunch' : 'ĞŸĞ¾Ğ»Ğ´Ğ½Ñ Ğ±ĞµĞ· Ğ¾Ğ±ĞµĞ´Ğ°'
  };
  return durations[duration] || duration;
}

function getSkillLevelText(level, language) {
  const levels = {
    'first-time': language === 'english' ? 'First Time' : 'ĞŸĞµÑ€Ğ²Ñ‹Ğ¹ Ñ€Ğ°Ğ·',
    'beginner': language === 'english' ? 'Beginner' : 'ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ÑÑ‰Ğ¸Ğ¹',
    'intermediate': language === 'english' ? 'Intermediate' : 'Ğ¡Ñ€ĞµĞ´Ğ½Ğ¸Ğ¹',
    'advanced': language === 'english' ? 'Advanced' : 'ĞŸÑ€Ğ¾Ğ´Ğ²Ğ¸Ğ½ÑƒÑ‚Ñ‹Ğ¹'
  };
  return levels[level] || level;
}

// ==================== WEB SERVER ROUTES ====================

// Ğ¡Ñ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ñ„Ğ¾Ñ€Ğ¼Ñ‹
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Health check endpoint
app.get('/health', async (req, res) => {
  try {
    if (!isDatabaseInitialized) {
      return res.status(503).json({ 
        status: 'ERROR', 
        database: 'initializing',
        message: 'Database is initializing, please wait...' 
      });
    }
    
    await pool.execute('SELECT 1');
    res.json({ 
      status: 'OK', 
      database: 'connected',
      initialized: isDatabaseInitialized,
      timestamp: new Date().toISOString() 
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'ERROR', 
      database: 'disconnected',
      error: error.message 
    });
  }
});

// Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ°
bot.launch().then(() => {
  console.log('ğŸ¤– SkiSchool.ge Bot Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½!');
  console.log('ğŸ‘‘ ĞĞ´Ğ¼Ğ¸Ğ½:', ADMIN_USERNAME);
  console.log('ğŸ¤– Ğ‘Ğ¾Ñ‚: @skischoolge_bot');
  console.log('ğŸ—„ï¸ Ğ‘Ğ°Ğ·Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…: MySQL on Railway');
}).catch(err => {
  console.error('Error launching bot:', err);
});

// Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ²ĞµĞ±-ÑĞµÑ€Ğ²ĞµÑ€Ğ°
const PORT = process.env.PORT || 3000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`ğŸš€ Web server running on port ${PORT}`);
  console.log(`ğŸŒ Health check: http://localhost:${PORT}/health`);
  console.log(`ğŸ“¨ Webhook URL: https://skischoolgebot-production.up.railway.app/webhook/booking`);
});

// Graceful shutdown
process.once('SIGINT', () => {
  console.log('Shutting down gracefully...');
  bot.stop('SIGINT');
  if (pool) pool.end();
});

process.once('SIGTERM', () => {
  console.log('Shutting down gracefully...');
  bot.stop('SIGTERM');
  if (pool) pool.end();
});
